# 2D CFAR 

This process consists of sliding a window through the complete Range-Doppler Map. The goal is to generate a thresholded block that separates
the range and doppler detection from noise. The first step is to determine the number of the training and guard cells both in
the range and doppler dimensions.

```
% *%TODO* :
%Select the number of Training Cells in both the dimensions.
Tr = 1;
Td = 2;

% *%TODO* :
%Select the number of Guard Cells in both dimensions around the Cell under 
%test (CUT) for accurate estimation
Gr = 1;
Gd = 2;
```

The offset noise is set to 12. Given the size of traning and guard cells, the number of training cells can be determined for the noise averaging process:

```
% number of training cells
Nt = (2 * Tr + 2 * Gr + 1) * (2 * Td + 2 * Gd + 1) - (2 * Gr + 1) * (2 * Gd + 1);
```
The size of the sliding window can be determined as well:

```
% *%TODO* :
%Create a matrix to store training cells for each iteration
window = zeros(2 * Tr + 2 * Gr + 1, 2 * Td + 2 * Gd + 1);
```

The thresholded block is defined as a matrix of the same size as the range doppler map generated by the 2D FFT.
At first, this block is initialized with zeros:

```
% Use RDM[x,y] as the matrix from the output of 2D FFT for implementing CFAR
CFAR = zeros(size(RDM));
[mapSize_r, mapSize_d] = size(RDM);
```

The next step is to iterate through both dimensions of the range-doppler map. We will determine the coordinates of the first CUT (cell under 
test). We do not consider cells that are in the borders. To do this, we limit the calculation only to cell locations that can host the entire
window. This is expressed at the beginning of the for loops. During every iteration step, the guard and CUT cell values are discarded. Only the values of the training cells are kept and converted from decibels to power.
The average noise is calculated and coverted back to decibels. The offset noise is added to this threshold. If the value of the CUT is higher
than the threshold, the new CFAR map will store 1 in this location. Otherwise, it will supress it by leaving the location with zero.

```
for CUT_index_r = Tr + Gr + 1:(mapSize_r - (Tr + Gr))
    for CUT_index_d = Td + Gd + 1:(mapSize_d - (Td + Gd))
        
        window = RDM(CUT_index_r - Gr - Tr: CUT_index_r + Gr + Tr, CUT_index_d - Gd - Td : CUT_index_d + Gd + Td); 
        
        % guard cells and cut are not considered for noise averaging
        window(CUT_index_r - Gr:CUT_index_r + Gr, CUT_index_d - Gd: CUT_index_d + Gd) = 0;
        
        window = db2pow(window);
        noise_level = sum(window)/Nt;
        noise_level = pow2db(noise_level);
   
        threshold = noise_level + offset;
        
        if RDM(CUT_index_r, CUT_index_d) > threshold
            CFAR(CUT_index_r, CUT_index_d) = 1;
        end
    end
end
```

### Selection of training and guard cells

This is basically a tuning process. The window pattern that is used in the udacity content for 2D CFAR is used. I think that the offset value is crucial to suppress the unwanted noise.

### Suppression of cells at the borders
The iteration process does not take into account cells that the window can not accomodate on. Those cells values are left to zero.
